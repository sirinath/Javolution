/*
 * Javolution - Java(TM) Solution for Real-Time and Embedded Systems
 * Copyright (C) 2012 - Javolution (http://javolution.org/)
 * All rights reserved.
 *
 * Permission to use, copy, modify, and distribute this software is
 * freely granted, provided that this notice is preserved.
 */
package javolution.xml.internal.annotation;

import java.lang.reflect.Field;
import java.lang.reflect.Method;
import java.lang.reflect.ParameterizedType;
import java.util.Iterator;

import javax.xml.bind.annotation.XmlAccessType;
import javax.xml.bind.annotation.XmlAccessorType;
import javax.xml.bind.annotation.XmlAttribute;
import javax.xml.bind.annotation.XmlType;
import javax.xml.datatype.XMLGregorianCalendar;

import javolution.text.CharArray;
import javolution.util.FastMap;
import javolution.util.FastSet;
import javolution.util.function.Equalities;

public abstract class AbstractJAXBAnnotationReflectionSupport {

	protected final FastMap<Field,Class<?>> _genericTypeCache;
	protected final FastMap<Class<?>,XmlAccessType> _xmlAccessTypeCache;
	protected final FastMap<Class<?>,Boolean> _basicInstanceCache;
	protected final FastMap<Class<?>,FastSet<Field>> _declaredFieldsCache;
	protected final FastMap<Class<?>, FastSet<CharArray>> _propOrderCache;
	protected final FastMap<Class<?>, FastSet<CharArray>> _requiredCache;
	protected final FastMap<CharArray,CharArray> _xmlElementNameCache;
	protected final FastMap<Field,CharArray> _fieldAttributeNameCache;

	public AbstractJAXBAnnotationReflectionSupport(){
		_genericTypeCache = new FastMap<Field,Class<?>>(Equalities.IDENTITY, Equalities.IDENTITY);
		_xmlAccessTypeCache = new FastMap<Class<?>,XmlAccessType>(Equalities.IDENTITY, Equalities.IDENTITY);
		_basicInstanceCache = new FastMap<Class<?>,Boolean>(Equalities.IDENTITY, Equalities.IDENTITY);
		_declaredFieldsCache = new FastMap<Class<?>,FastSet<Field>>(Equalities.IDENTITY, Equalities.IDENTITY);
		_xmlElementNameCache = new FastMap<CharArray, CharArray>(Equalities.CHAR_ARRAY_FAST, Equalities.CHAR_ARRAY_FAST);
		_propOrderCache = new FastMap<Class<?>, FastSet<CharArray>>(Equalities.IDENTITY, Equalities.IDENTITY);
		_requiredCache = new FastMap<Class<?>, FastSet<CharArray>>(Equalities.IDENTITY, Equalities.IDENTITY);
		_fieldAttributeNameCache = new FastMap<Field,CharArray>(Equalities.IDENTITY, Equalities.IDENTITY);
	}

	protected boolean isInstanceOfBasicType(final Class<?> objClass){
		Boolean basicInstance = _basicInstanceCache.get(objClass);

		if(basicInstance == null){
			basicInstance = (objClass.isAssignableFrom(Long.class) ||
					objClass.isAssignableFrom(Integer.class) ||
					objClass.isAssignableFrom(String.class) ||
					objClass.isAssignableFrom(XMLGregorianCalendar.class) ||
					objClass.isAssignableFrom(Boolean.class) ||
					objClass.isEnum() || objClass.isPrimitive() ||
					objClass.isAssignableFrom(Double.class) ||
					objClass.isAssignableFrom(Float.class) ||
					objClass.isAssignableFrom(Byte.class) ||
					objClass.isAssignableFrom(Short.class));
			_basicInstanceCache.put(objClass, basicInstance);
		}

		return basicInstance;
	}

	protected XmlAccessType getXmlAccessType(final Class<?> objectClass){
		XmlAccessType xmlAccessType = _xmlAccessTypeCache.get(objectClass);

		if(xmlAccessType == null && !_xmlAccessTypeCache.containsKey(objectClass)){
			if(objectClass.isAnnotationPresent(XmlAccessorType.class)){
				xmlAccessType = objectClass.getAnnotation(XmlAccessorType.class).value();
				_xmlAccessTypeCache.put(objectClass, xmlAccessType);
			}
		}

		return xmlAccessType;
	}

	protected Class<?> getGenericType(final Field field){
		Class<?> genericType = _genericTypeCache.get(field);

		if(genericType == null){
			final ParameterizedType type = (ParameterizedType)field.getGenericType();
			genericType = (Class<?>)type.getActualTypeArguments()[0];
			_genericTypeCache.put(field, genericType);
		}

		return genericType;
	}

	protected FastSet<Field> getDeclaredFields(final Class<?> classObject){
		FastSet<Field> declaredFields = _declaredFieldsCache.get(classObject);

		if(declaredFields == null){
			Class<?> thisClassObject = classObject;
			declaredFields = new FastSet<Field>(Equalities.IDENTITY);

			do {
				final Field[] fields = thisClassObject.getDeclaredFields();

				for(final Field field : fields){
					field.setAccessible(true);
					declaredFields.add(field);
				}
			}
			while((thisClassObject = thisClassObject.getSuperclass()) != null);

			_declaredFieldsCache.put(classObject, declaredFields);
		}

		return declaredFields;
	}

	protected FastSet<Method> getDeclaredMethods(final Class<?> classObject){
		Class<?> thisClassObject = classObject;
		final FastSet<Method> declaredMethods = new FastSet<Method>(Equalities.IDENTITY);

		do {
			final Method[] methods = thisClassObject.getDeclaredMethods();

			for(final Method method : methods){
				method.setAccessible(true);
				declaredMethods.add(method);
			}
		}
		while((thisClassObject = thisClassObject.getSuperclass()) != null);

		return declaredMethods;
	}

	protected Iterator<CharArray> getXmlPropOrder(final Class<?> classObject){
		FastSet<CharArray> propOrderSet = _propOrderCache.get(classObject);

		if(propOrderSet == null && classObject.isAnnotationPresent(XmlType.class)){
			final XmlType xmlType = classObject.getAnnotation(XmlType.class);

			propOrderSet = new FastSet<CharArray>(Equalities.CHAR_ARRAY_FAST);

			for(final String prop : xmlType.propOrder()){
				propOrderSet.add(getXmlElementName(prop));
			}

			_propOrderCache.put(classObject, propOrderSet);
		}

		return propOrderSet == null ? null : propOrderSet.iterator();
	}

	protected CharArray getXmlElementName(final String nameString){
		final CharArray name = new CharArray(nameString);
		CharArray xmlElementName = _xmlElementNameCache.get(name);

		if(xmlElementName == null){
			//LogContext.info("<NEW INSTANCE XML ELEMENT NAME>");
			synchronized(_xmlElementNameCache){
				xmlElementName = _xmlElementNameCache.putIfAbsent(name, name);
				if(xmlElementName == null) return name;
			}
		}

		return xmlElementName;
	}

	protected CharArray getXmlElementName(final CharArray localName){
		CharArray xmlElementName = _xmlElementNameCache.get(localName);

		if(xmlElementName == null){
			//LogContext.info("<NEW INSTANCE XML ELEMENT NAME>");
			xmlElementName = copyCharArrayViewport(localName);
			_xmlElementNameCache.put(xmlElementName, xmlElementName);
		}

		return xmlElementName;
	}

	private static CharArray copyCharArrayViewport(final CharArray charArray){
		final CharArray outputArray = new CharArray();
		final char[] array = new char[charArray.length()];
		System.arraycopy(charArray.array(), charArray.offset(), array, 0, array.length);
		outputArray.setArray(array, 0, array.length);
		return outputArray;
	}

	protected CharArray getXmlAttributeName(final Field field){
		CharArray xmlAttributeName = _fieldAttributeNameCache.get(field);

		if(xmlAttributeName == null){
			final XmlAttribute thisAttribute = field.getAnnotation(XmlAttribute.class);
			xmlAttributeName = new CharArray(thisAttribute.name());
			_fieldAttributeNameCache.put(field, xmlAttributeName);
		}

		return xmlAttributeName;
	}
}
