<body>
<p> Provides real-time {@link javolution.realtime.Context} for higher
    performance and higher predictability of Java bytecode execution.</p>

<h2><a name="OVERVIEW">Overview:</a></h2>

<p> <i><b>J</b>avolution</i> real-time framework provides additional "objects spaces" others than the heap space;
    such as the "stack" space or the "hold" space. 
    The object space determines when recycling does occur:
    <UL>
    <LI> Heap        : Recycled with the container object if any; otherwise recycled when the object is not reachable (gc).</LI>
    <LI> Stack       : Recycled when the current thread exits the scope of the PoolContext where the object has been "factory produced".</LI>
    <LI> Hold        : Recycled when internal {@link javolution.realtime.RealtimeObject#preserve preserve} count drops to zero.</LI>
    </UL>
    Any Java(tm) object (or array) can be produced using a static 
    {@link javolution.realtime.ObjectFactory ObjectFactory} and therefore can 
    be pre-allocated (at any appropriate time) or stack allocated.</P>

<P> This facility works with any VM or even native executable (GCJ). 
    It is also well suited for <a href="http://www.rtj.org/">RTSJ</a> VMs
    <UL> 
    <LI> To avoid IllegalAssignmentError. Objects can be prea-allocated in immortal memory during class initialization.</LI>
    <LI> To avoid MemoryAccessError. NoHeapRealTimeThread can always access objects in immortal memory.</LI>
    </UL></P>
    
<P> <i><b>J</b>avolution</i> also allows your application to control when object allocation 
    does occur! In other words, even when using the default heap space, you can move object 
    allocation and garbage collection out of the picture. For example:<pre>
      void main(String[]) {
          AllocationProfile.load(); // Loads allocation profile from previous executions.
          Music music = getMusicToPlay();
          while (music != null) {
              AllocationProfile.preallocate(); // Delay ok, not started yet.
              play(music); // Real-time and fast (no object creation and no gc).
          }
          AllocationProfile.save(); // Saves allocation profile (optional).
     }</pre>
     </P>

<h2><a name="FAQ">FAQ:</a></h2>
<ol>
    <a name="FAQ-1"></a>
    <li><b>Can you explain a little how the PoolContext works? 
    I looked at the example code in the Javadoc, and I'm still a little fuzzy on where and what 
    the "magic" is that it performs...</b>
    <p> 
    The basic idea is to associate objects pools to Java threads. 
    These pools can be nested, with the heap being the root of all pools.
    You may consider pools' objects as part of the thread stack memory, with pools being pushed and 
    popped as the thread enters/exits {@link javolution.realtime.PoolContext PoolContext}.
    To allocate from its <b>stack</b>, a thread needs to execute within a pool context
    and create <i>new</i> objects using {@link javolution.realtime.ObjectFactory factories}
    (the "new" keyword always allocates on the heap, Javolution does not/cannot change 
    the Java Virtual Machine behavior). This mechanism is similar to the allocation
    on the stack of locally declared primitive variables, but now extended to
    non-primitive objects.
    </p> 
    <p><i> Note: Classes encapsulating calls to object factories within
                their factory methods (e.g. <code>valueOf(...)</code>) and 
                whose methods do not allocate directly on the heap are known
                as "real-time compliant".</i></p>
    </li><p></p>

    <a name="FAQ-2"></a>
    <li><b>How do I make my own classes real-time compliant?</b>
    <p> The simplest way is to extend {@link javolution.realtime.RealtimeObject RealtimeObject}
        and use a factory to create new instances. For example:<pre>
    public final class Coordinates extends RealtimeObject {
        private double latitude;
        private double longitude;        
        private static final Factory FACTORY = new Factory() {
              public Object create() {
                  return new Coordinates();
              }
        };
       private Coordinates() {} 
       public static Coordinates valueOf(double latitude, double longitude) {
           Coordinates c = (Coordinates) FACTORY.object();
           c.latitude = latitude;
           c.longitude = longitude;
           return c;
       }
    }</pre>
    Et voila! Your class is now real-time compliant!
    <p> The following code shows the accelerating effect of pool contexts.<pre>
     public static void main(String[] args) {
         Coordinates[] vertices = new Coordinates[1000000];
         for (int i=0; i < 10; i++) {     
             long time = System.currentTimeMillis();
             PoolContext.enter();
             try {
                 for (int j = 0; j < vertices.length; j++) {
                     vertices[j] = Coordinates.valueOf(i, j);
                 }
             }finally {
                 PoolContext.exit();
             }
             time = System.currentTimeMillis()-time;
             System.out.println("Time = " + time);
         }
     }</pre>
        The first iteration is always slower as objects are allocated from the heap
        and populate the stack.<br> 
        Subsequent iterations are not only faster but 
        very consistent in time as no memory allocation/garbage collection 
        will ever occur.<pre> 
  Time = 1547
  Time = 93
  Time = 94
  Time = 94
  Time = 94
  Time = 93
  Time = 94
  Time = 94
  Time = 93
  Time = 94</pre>
  <i>Note: You may avoid the initial high cost of the first iteration by loading 
           the application {@link javolution.realtime.AllocationProfile allocation profile}
           at start-up.</i>
    
  <p> The same program allocating directly on the heap (e.g. <code>new Coordinates(i, j)</code>)
     produces the following result:<pre>
  Time = 937
  Time = 703
  Time = 1078
  Time = 641
  Time = 656
  Time = 656
  Time = 641
  Time = 671
  Time = 641
  Time = 656</pre> 
  Not only code execution is <b>6x</b> time slower but there is much 
  more fluctuation in the execution time due to GC.</p>
    </li><p></p>
    
    <a name="FAQ-3"></a>
    <li><b>As a rule, I am skeptical of classes that pool small objects. 
     At one time (5 years ago) it was a big win. Over time, the advantage has 
     diminished as garbage collectors improve. Object pools can make it much more
     difficult for the garbage collector to do its job efficiently, and can have
     adverse effects on footprint. (Joshua Bloch) </b>
    <p> Stack allocation is a simple and transparent way to make your methods "clean" (no garbage 
        generated), it has also the side effect of making your methods faster 
        and more time-predictable. If all your methods are "clean" then your whole 
        application is "clean", faster and more time-predictable (aka real-time).</p>
    <p> Applications may use the facility to different degrees. 
        For example, to improve performance one might identify the biggest "garbage producers" 
        and use stack allocations instead of heap allocations for those only. 
        Others might want to run high priority threads in a pool context and
        by avoiding heap allocations (and potential GC wait), make these threads highly deterministic.</p>
    <p> In practice, very few methods declare a pool context for local stack allocations, 
        only the "dirty" ones (the one generating a lot of  garbage). Iterations are often good
        candidates as they typically generate a lot of garbage. For example:<pre>
   public Matrix pow(int exp) {
       PoolContext.enter(); // Starts local stack allocation.
       try { 
           Matrix pow2 = this;
           Matrix result = null;
           while (exp >= 1) { // Iteration.
                if ((exp & 1) == 1) {
                   result = (result == null) ? pow2 : result.multiply(pow2);
                }
                pow2 = pow2.multiply(pow2);
                exp >>>= 1;
           } 
           return (Matrix) result.export(); // Exports result to outer stack (or heap).
       } finally {
            PoolContext.exit(); // Resets local stack (all temporary objects recycled at once).
       }
    }</pre></p>
    <P> For the very "dirty" (e.g. very long interations), one pool context
        might not be enough and may cause memory overflow. You might have
        to break down the iteration loop and use inner contexts.<pre>
    Product[] products = ... // Very long array.
    Money total = Money.ZERO;
    PoolContext.enter();
    try { 
        for (int i=0; i < products.length;) {
            PoolContext.enter(); // Inner pool context.
            try {
                // Processes up to 1024 products at a time.
                for (int j=0; (j < 1024) && (i < products.length); j++) {
                    total = total.add(products[i++].price());
                } 
                total.export();
            } finally {
                PoolContext.exit();
            }
        }
        total.export();
    } finally {
        PoolContext.exit();
    }</pre>
  <i>Note: By using multiple layers of small nested pool contexts instead of a single
           large pool, one keeps the pools' memory footprint very low and still 
           benefits fully from the facility. Pools of a few dozens objects are
           almost as efficient as larger pools. This is because entering/exiting
           pool contexts is fast and the CPU cache is more effective with small pools.</i></p>
    <p>Individual recycling is possible for methods having access 
       to the object pool. It is the case for member methods (ref.
       <b>protected</b> method {@link javolution.realtime.RealtimeObject#recycle recycle}) and
       methods having direct access to the {@link javolution.realtime.ObjectFactory factory} 
       instances (usually <b>private</b>).<pre>
    // Arrays.
    static final ObjectFactory CHAR1024_FACTORY = new ObjectFactory() { 
        public Object create() { return new char[1024]; }
    };
    ...
    char[] buffer = (char[]) CHAR1024_FACTORY.object(); // Gets buffer from stack (or heap).
    for (int i = reader.read(buffer, 0, buffer.length); i > 0;) {
        ...
    } 
    CHAR1024_FACTORY.currentPool().recycle(buffer); // Puts object back immediatly (optional).
    
    // Member method may use of <b>protected</b> recycle method.
    public LargeInteger gcd(LargeInteger that) {
        LargeInteger a = this.abs();
        LargeInteger b = that.abs();
        while (!b.isZero()) {
            LargeInteger tmp = a.divide(b);
            LargeInteger c = tmp.getRemainder();
            tmp.recycle(); // Individual recycling affects local objects only 
            a.recycle();   // (no effect on heap objects or outer objects).
            a = b;
            b = c;
        }
        return a;
    }</pre></p>
    </li><p></p>

    <a name="FAQ-4"></a>
    <li><b>Are not PoolContext inherently unsafe (e.g. immutable objects changing
        suddenly values) ?</b>
    <p> No, as long as you {@link javolution.realtime.RealtimeObject#export export} or 
        {@link javolution.realtime.RealtimeObject#preserve preserve} the
        objects which might be referenced outside of the pool context,
        <b>immutable objects stay immutable!</b> Furthermore, you do not have to 
        worry about thread synchronization as stack objects are thread-local.</p>
    <p> In practice, <b>very few</b> methods have to worry about the "export rule". 
        They are:</p>
        <ol>
        
        <li><p>The methods with the pool context <b><code>try, finally</code></b> block statement defined. 
            They have to ensure that objects created/modified inside the context scope and 
            accessible outside of the scope are {@link javolution.realtime.RealtimeObject#export exported}.</p></li>
            
        <li><p> The methods creating or modifying <b><code>static</code></b> objects.
            Becauses <code>static</code> objects can be accessed from any thread, local objects 
            need to be {@link javolution.realtime.RealtimeObject#moveHeap moved to the heap}
            or {@link javolution.realtime.RealtimeObject#preserve preserved}/
            {@link javolution.realtime.RealtimeObject#unpreserve unpreserved} when made accessible
            from a static object.</i></li>
        </ol>
    <p> For additional safety, <b>IllegalAccessError</b> are raised during execution when  
        the rules above are broken.</p>
    <p> In truth, object spaces promote the use of immutable objects 
        (as their allocation cost is being significantly reduced), reduces thread 
        interaction (e.g. race conditions) and often lead to safer, faster and more
        robust applications.</p>
    </li><p></p>

    <a name="FAQ-5"></a>
    <li><b>Our application is hard real-time, we cannot afford to run GC 
        ever, can we still use Javolution ?</b>
    <p> <b>A resounding Yes!</b> The easiest way is to ensure that all your threads
         run in a pool context, only static constants are exported to 
         the heap and your system state can be updated without allocating new objects.
         This last condition is easily satisfied by using mutable objects or 
         by {@link javolution.realtime.RealtimeObject#preserve preventing} local (on the stack)
         immutable objects from being automatically recycled. The following illustrates
         this capability (no synchronization required).<pre>
         class Navigator extends Thread {
             private Coordinates position = Coordinates.valueOf(0, 0);
             public void run() {
                 while (true) {
                     PoolContext.enter();
                     try {
                         Coordinates newPosition = calculatePosition(); // On the stack.
                         synchronized (this) {
                             position.unpreserve(); // Allows old position to be recycled.
                             position = newPosition;
                         }    
                     } finally {                     
                         position.preserve(); // Prevents recycling of new position upon exit.
                         PoolContext.exit();
                     }
                 }
             }
             public synchronized getPosition() { // On the stack.
                 return position.copy();
             }
          }</pre></p>

         <IMG alt="Hard Real-Time Application (no GC ever)" src="doc-files/realtime.jpg">

         <p> Finally, some JDK library classes may create temporary objects on the heap and 
         therefore should be avoided or replaced by "cleaner" classes 
         (e.g. {@link javolution.util.FastMap FastMap} instead of <code>java.lang.HashMap</code>,
         {@link javolution.lang.TextBuilder TextBuilder} instead of <code>java.lang.StringBuffer</code> 
         (<code>setLength(0)</code> allocates a new internal array) and
         {@link javolution.lang.TypeFormat TypeFormat} for parsing/formatting of primitive types).</p>
    </li><p></p>

    <a name="FAQ-6"></a>
    <li><b>What performance gain can I expect by using a pool context?</b>
    <p> Classes avoiding dynamic memory allocation are significantly faster.
        For example, our XML {@link javolution.xml.sax.RealtimeParser RealtimeParser}
        is <b>3-5x</b> faster than conventional SAX2 parsers. To avoid synchronization 
        issues, it is often easier to allocate new objects. Other techniques such 
        as the "returnValue" parameter are particularly ugly and unsafe
        as they require mutability. Javolution's real-time facility promotes the dynamic 
        creation of immutable objects as these object creations are fast and have no adverse
        effect on garbage collection. Basically, with pool contexts, <b> the CPU is 
        busy doing the "real thing" not "memory management"!</b></p>
    <p> The cost of allocating on the heap is somewhat <b>proportional
        to the size</b> of the object being allocated. By avoiding or postponing this
        cost you can drastically increase the execution speed.<b> The largest objects
        benefit the most.</b> For example, adding <code>org.jscience.math.numbers.LargeInteger</code>
        in a pool context is at least <b>5x</b> faster than adding 
        <code>java.math.BigInteger</code>, our public domain {@link javolution.lang.Text Text}
        can be <b>several orders of magnitude faster</b> than <code>java.lang.String</code>
       (see <a href="http://javolution.org/doc/benchmark.html">benchmark</a>).
        Not surprising when you know that even "empty" <code>Strings</code> 
        take 40 bytes of memory which have to be initialized and garbage collected!</p>
    <p> Recycling objects is way more powerful than just recycling memory (aka GC).
        Our {@link javolution.util.FastMap FastMap} is 
        a complex object using preallocated linked lists. It is fast but costly
        to build. Nevertheless, in a pool context it can be used as a throw-away map
        because <b>the construction cost is then reduced to nothing!</b></p>
    </li><p></p>

    <a name="FAQ-7"></a>
    <li><b>Virtual Machines with concurrent garbage collection are becoming more
           and more popular. Do we still need a real-time facility?</b>
    <p> Concurrent garbage collection is a perfect complement to Javolution real-time facility
        (Ref. <a href="http://developer.java.sun.com/developer/technicalArticles/Programming/turbo/">
        New Hotspot<sup>TM</sup> JVM</a>). In particular, without preemptable
        garbage collection we cannot ensure that periodic real-time threads start on-time.</p>
    <p> For real-time applications, the advantages of the facility are threefold:
        <ul><li> Faster execution. Objects have already been allocated, initialized 
                 and are more likely to be in the CPU cache <b>(increases responsiveness)</b>.</li>
            <li> By limiting/eliminating garbage, we ensure that a concurrent collector
                 can always keep up with the garbage flow and avoid a stop-the-world collection
                 situation (a disaster for real-time system). Furthermore, the 
                 collector total CPU usage can be significantly reduced <b>(maximizes processing efficiency)</b>.</li>
            <li> <code>ConcurrentContext</code> are easy to use in low-level operations 
                 and have almost no overhead. On multi-processors systems (including processors
                 with Hyper-Threading technology) sequential high-level operations can automatically
                 take advantage of all processors available <b>(optimizes CPU repartition)</b>.</li>
        </ul></p>
   <p>  Nowadays, more and more virtual machines with schedulable/time-bounded garbage collectors are available
        (e.g. <a href="http://www.aicas.com/">Jamaica VM</a> or <a href="http://www.aonix.com/perc.html">PERC VM</a>)
        These VMs have one thing in common though. If they cannot keep up with the garbage flow they 
        revert to a "stop the world" collection (no much choice there). 
        Therefore, there is a good incentive to limit garbage either by manually pooling objects
        (error prone) or by using solutions such as the one advocated here (easier and safer).</p>
   <p>  For applications based upon the Real-Time Specification for Java (<a href="http://www.rtj.org/">RTSJ</a>)
        all threads (including <code>NoHeapRealtimeThread</code>) can run in 
        <code>ImmortalMemory</code> (with pool contexts for the recycling) and avoid memory clashes!</p>
    </li><p></p>
</ol>
<h2><a name="CONCLUSION">Conclusion:</a></h2>
        Soft/Hard Real-Time applications can significantly benefit
        from this (small) package. It would be nice if it came standard with the Java library.
        Direct JVM support of thread-local stacks and making the <i>new</i> keyword context sensitive
        would make Java more powerful, deterministic and execute faster!
        This changes would be backward compatible as the default context for normal threads
        is the heap context.<br>
        If Sun<sup>TM</sup> is interested, I am willing to transfer all rights 
        to them at <b>no cost</b>!
</body>