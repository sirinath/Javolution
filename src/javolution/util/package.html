<BODY>
<P> Provides high-performance collection classes and miscellaneous utilities; although 
    this package provides very few collection classes, they are substitutes for
    most of <code>java.util.*</code> classes (for example, <code>java.util.IdentityHashMap</code> would be 
    a {@link javolution.util.FastMap FastMap} with an {@link javolution.util.FastComparator#IDENTITY
    identity} key comparator).</P>

<P> Javolution collections are compliant with standard collections (generic when built with the ant target <code>1.5</code>).</P>

<P> They support direct iterations with the following advantages:
    <UL>
    <LI>Faster than iterators, see <A href="http://javolution.org/doc/benchmark.html">benchmark</A>.</LI>
    <LI>No object creation not even the iterator object itself. For example, visiting a tree structure using
        iterators creates as many iterators as they are nodes in the tree:<pre>
        public static void visit(Collection&lt;Collection&gt; node) {
            for (Collection&lt;Collection&gt; i : node) { // Creates iterator.
                visit(i);
            }
        }</pre>
        Not so with direct iterations:<pre>
        public static void visit(FastCollection&lt;FastCollection&gt; node) {
            for (FastCollection.Record r = node.head(), end = node.tail(); (r = r.getNext()) != end;) {
                visit(node.valueOf(r));
            }
        }</pre></LI>
    <LI>Used to implement most of {@link javolution.util.FastCollection FastCollection} base class methods 
        (including {@link javolution.util.FastCollection#iterator iterator()}).</LI>
    <LI>Support forward/backward iterations from the start (head) or from the end (tail)</LI>
    <LI>Thread-Safe as long as the record sequence iterated over is not modified by another thread.
        Objects can safely be append/prepend by other threads during iteration but not inserted/removed
        <i>(Note: {@link javolution.util.FastMap#setShared Shared FastMap} <b>do support</b> 
        concurrent entry removal)</i>.</LI>
    <LI>Fully integrated with the JDK1.5+ generic framework (strong typing) and still compatible 
        with other platforms (J2ME, 1.4, GCJ).</LI>
    </UL>
    Here are few examples of direct iterations:<pre>
        FastList&lt;String&gt; list;
        for (FastList.Node&lt;String&gt; n = list.head(), end = list.tail(); (n = n.getNext()) != end;) {
             String value = n.getValue(); // No typecast necessary.    
        }
        ...
        FastMap&lt;String, Thread&gt; map;
        for (FastMap.Entry&lt;String, Thread&gt; e = map.head(), end = map.tail(); (e = e.getNext()) != end;) {
             String key = e.getKey(); // No typecast necessary.
             Thread value = e.getValue(); // No typecast necessary.
        }</pre></P>

<P> Users may provide a read-only view of any {@link javolution.util.FastCollection FastCollection} 
    (or {@link javolution.util.FastMap FastMap}) instance using the 
    {@link javolution.util.FastCollection#unmodifiable() FastCollection.unmodifiable()}
    (or {@link javolution.util.FastMap#unmodifiable FastMap.unmodifiable()}) method.
     For example:<pre>
       public class Unit { // Immutable and unique.
       
          private static final FastSet&lt;Unit&gt; UNITS = new FastSet&lt;Unit&gt;();

          // Read-only view (also thread-safe as units are never "deleted")
          public static FastCollection&lt;Unit&gt; getInstances() { 
              return UNITS.unmodifiable();
          }
      }</pre></P>

<P> {@link javolution.util.FastMap FastCollection} classes support concurrent access without synchronization as long as the
    records are not removed and not inserted at arbitrary position (appending to the end of the collection is fine).
    For {@link javolution.util.FastMap FastMap}, unsynchronized concurrent access can be 
    guaranteed by making the map {@link javolution.util.FastMap#setShared shared}.
    For example:<pre>
        public class XmlFormat {
             
             // Class to format mapping is shared between multiple threads (static).
             static final FastMap&lt;Class, XmlFormat&gt; CLASS_TO_FORMAT = new FastMap&lt;Class, XmlFormat&gt;().setShared(true);
             
             public static XmlFormat getInstance(Class forClass) {
                 return CLASS_TO_FORMAT.get(forClass); // No synchronization needs to occur.
             }
             
             public static void setFormat(Class forClass, XmlFormat xmlFormat) {
                 CLASS_TO_FORMAT.put(forClass, xmlFormat); // Internal synchronization occurs (shared map).
             } 
        }</pre></P>

<P>  Although all collections capacity increases smoothly (no resizing/copy or rehashing ever performed),
     it is nevertheless possible to specify an initial capacity; in which case, <b>no dynamic 
     memory allocation is ever performed</b> as long as the collection size does not exceeds the specified 
     capacity and regardless of the operation being performed (e.g. lazy initialization is prohibited)! 
     This particularity allows <a href="http://www.rtj.org/">RTSJ</a> applications to allocate
     collections in immortal memory and make them accessible by all threads (including <code>NoHeapRealtimeThread</code>)</P>
     Here is a summary of the collection classes with their defining characteristics:
       <TABLE border="1" summary="Fast Collections Classes">
            <CAPTION><EM><B>Javolution Collections Classes</B></EM></CAPTION>
            <TR>
              <TD></TD>
              <TD><B>Ordering</B></TD>
              <TD><B>Duplication Allowed</B></TD>
              <TD><B>Custom Comparators</B></TD>
              <TD><B>Record Type</B></TD>
              <TD><B>Miscellaneous</B></TD>
            </TR>
            <TR>
              <TD>{@link javolution.util.FastTable FastTable}</TD>
              <TD>Insertion Order</TD>
              <TD>Yes</TD>
              <TD>{@link javolution.util.FastCollection#setValueComparator setValueComparator(FastComparator)}</TD>
              <TD>{@link javolution.util.FastTable.Index Index}</TD>
              <TD>Thread-safe random access collection<BR>
                  No array resize/copy ever performed</TD>
            </TR>
            <TR>
              <TD>{@link javolution.util.FastList FastList}</TD>
              <TD>Insertion Order</TD>
              <TD>Yes</TD>
              <TD>{@link javolution.util.FastCollection#setValueComparator setValueComparator(FastComparator)}</TD>
              <TD>{@link javolution.util.FastList.Node Node}</TD>
              <TD> Recycle their own nodes (no adverse effect on GC)</TD>
            </TR>
            <TR>
              <TD>{@link javolution.util.FastSet FastSet}</TD>
              <TD>Insertion Order</TD>
              <TD>No</TD>
              <TD>{@link javolution.util.FastList#setValueComparator setValueComparator(FastComparator)}</TD>
              <TD>{@link javolution.util.FastCollection.Record Record}</TD>
              <TD>Based on {@link javolution.util.FastSet FastMap} (same characteristics)</TD>
            </TR>
            <TR>
              <TD><CODE>FastTree</CODE></TD>
              <TD>Comparator</TD>
              <TD>No</TD>
              <TD><CODE>setValueComparator(FastComparator)</CODE></TD>
              <TD><CODE>TreeNode</CODE></TD>
              <TD><I>(not implemented)</I></TD>
            </TR>
            <TR>
              <TD>{@link javolution.util.FastMap FastMap}</TD>
              <TD>Insertion Order</TD>
              <TD>Key: No<BR>Value: Yes</TD>
              <TD>{@link javolution.util.FastMap#setKeyComparator setKeyComparator(FastComparator)}<BR>
                  {@link javolution.util.FastMap#setValueComparator setValueComparator(FastComparator)}</TD>
              <TD>{@link javolution.util.FastMap.Entry Entry}</TD>
              <TD>Thread-safe when marked as {@link javolution.util.FastMap#setShared shared}<BR>
                  No rehash/resize ever performed <BR>
                  Unshared hash map recycles their own entries (no adverse effect on GC)</TD>
            </TR>
         </TABLE>
    </P>    
</BODY>