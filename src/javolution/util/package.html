<BODY>
<P> Provides high-performance collection classes and miscellaneous utilities; although 
    this package provides very few collection classes, they are substitutes for
    most of <code>java.util.*</code> classes (for example, <code>java.util.IdentityHashMap</code> would be 
    a {@link javolution.util.FastMap FastMap} with an {@link javolution.util.FastComparator#IDENTITY
    identity} key comparator).</P>

<P> Javolution collections are generics when built with the ant target <code>1.5</code>.
    They all support direct iterations with the following advantages:
    <UL>
    <LI>Fully compliant with standard collections interfaces (Map, List, Set, etc).</LI>
    <LI>Faster than iterators, see <A href="http://javolution.org/doc/benchmark.html">benchmark</A>.</LI>
    <LI>No object creation (such as the iterator object itself)</LI>
    <LI>Run on all platforms from J2ME to J2EE 1.5 (generic when built with ant target 1.5).</LI>
    <LI>Support forward/backward iterations from the start (head) or from the end (tail)</LI>
    <LI>Thread-Safe as long as the record sequence iterated over is not modified by another thread
       (objects can safely be append/prepend by other threads during iteration but not inserted/removed).</LI>
    <LI>Fully integrated with the generic framework (strong typing).</LI>
    </UL>
    Here are few examples of direct iterations:<pre>
        FastList&lt;String&gt; list = new FastList&lt;String&gt;();
        for (FastList.Node&lt;String&gt; n = list.headNode(), end = list.tailNode(); (n = n.getNextNode()) != end;) {
             String value = n.getValue(); // No typecast necessary.    
        }
        ...
        FastMap map = new FastMap&lt;String, Thread&gt;();
        for (FastMap.Entry&lt;String, Thread&gt; e = map.headEntry(), end = map.tailEntry(); (e = e.getNextEntry()) != end;) {
             String key = e.getKey(); // No typecast necessary.
             Thread value = e.getValue(); // No typecast necessary.
        }
        ...
        static boolean contains(Object obj, FastCollection c) { // General collection iterations.
            for (FastCollection.Record r = c.headRecord(), end = c.tailRecord(); (r = r.getNextRecord()) != end;) {
                 if (obj.equals(c.valueOf(r))) return true;
            }
            return false;
        }</pre></P>

<P> Users may provide a read-only view of any {@link javolution.util.FastCollection FastCollection} 
    (or {@link javolution.util.FastMap FastMap}) instance using the 
    {@link javolution.util.FastCollection#unmodifiable() FastCollection.unmodifiable()}
    (or {@link javolution.util.FastMap#unmodifiable FastMap.unmodifiable()}) method.
     For example:<pre>
       public class Unit { // Immutable and unique.
          private final FastSet&lt;Unit&gt; _units = new FastSet&lt;Unit&gt;();
          // Read-only view (also thread-safe as units are never "deleted")
          public FastCollection&lt;Unit&gt; getInstances() { 
              return _units.unmodifiable();
          }
      }</pre></P>

<P> Javolution collection classes support concurrent access without synchronization as long as the
    records are not removed (e.g. {@link javolution.util.FastMap FastMap} look-up table).
    To keep read access unsynchronized when records are deleted, applications may either replace 
    the whole collection/map or better set the record value to <code>null</code> instead of removing it.
    Structural modifications themselves should always be synchronized. For example:<pre>
        class XmlFormat {
             static FastMap&lt;Class, XmlFormat&gt; classToFormat = new FastMap&lt;Class, XmlFormat&gt;();
             static XmlFormat getInstance(Class forClass) {
                 return classToFormat.get(forClass); // Unsynchronized read.
             }
             void setClass(Class clazz) {
                 synchronized (classToFormat) {      // Synchronized update.
                     classToFormat.put(clazz, this);
                 }
             } 
        }</pre></P>

<P>  Although all collections capacity increases smoothly (no resizing/copy or rehashing ever performed),
     it is nevertheless possible to specify an initial capacity; in which case, <b>no dynamic 
     memory allocation is ever performed</b> as long as the collection size does not exceeds the specified 
     capacity and regardless of the operation being performed (e.g. lazy initialization is prohibited)! 
     This particularity allows <a href="http://www.rtj.org/">RTSJ</a> applications to allocate
     collections in immortal memory and make them accessible by all threads (including <code>NoHeapRealtimeThread</code>)</P>
     Here is a summary of the collection classes with their defining characteristics:
       <TABLE border="1" summary="Fast Collections Classes">
            <CAPTION><EM><B>Javolution Collections Classes</B></EM></CAPTION>
            <TR>
              <TD></TD>
              <TD><B>Ordering</B></TD>
              <TD><B>Duplication Allowed</B></TD>
              <TD><B>Custom Comparators</B></TD>
              <TD><B>Record Type</B></TD>
              <TD><B>Miscellaneous</B></TD>
            </TR>
            <TR>
              <TD>{@link javolution.util.FastList FastList}</TD>
              <TD>Insertion Order</TD>
              <TD>Yes</TD>
              <TD>{@link javolution.util.FastList#setValueComparator setValueComparator(FastComparator)}</TD>
              <TD>{@link javolution.util.FastList.Node Node}</TD>
              <TD>Reusable linked-list (recycles its nodes)</TD>
            </TR>
            <TR>
              <TD>{@link javolution.util.FastSet FastSet}</TD>
              <TD>Insertion Order</TD>
              <TD>No</TD>
              <TD>{@link javolution.util.FastList#setValueComparator setValueComparator(FastComparator)}</TD>
              <TD>{@link javolution.util.FastCollection.Record Record}</TD>
              <TD>Based on {@link javolution.util.FastSet FastMap} (same characteristics)</TD>
            </TR>
            <TR>
              <TD><CODE>FastTree</CODE></TD>
              <TD>Comparator</TD>
              <TD>No</TD>
              <TD><CODE>setValueComparator(FastComparator)</CODE></TD>
              <TD><CODE>TreeNode</CODE></TD>
              <TD><I>(not implemented)</I></TD>
            </TR>
            <TR>
              <TD>{@link javolution.util.FastMap FastMap}</TD>
              <TD>Insertion Order</TD>
              <TD>Key: No<BR>Value: Yes</TD>
              <TD>{@link javolution.util.FastMap#setKeyComparator setKeyComparator(FastComparator)}<BR>
                  {@link javolution.util.FastMap#setValueComparator setValueComparator(FastComparator)}</TD>
              <TD>{@link javolution.util.FastMap.Entry Entry}</TD>
              <TD>Thread-safe access without synchronization if the keys are not removed (e.g. look-up table)<BR>
                  No rehash/resize ever performed (and no capacity to specify)<BR>
                  Reusable hash map (recycles its entries)</TD>
            </TR>
         </TABLE>
    </P>    
</BODY>