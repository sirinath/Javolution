<BODY>
<P> Provides high-performance collection classes and miscellaneous utilities; although 
    this package provides very few collection classes, they are substitutes for
    most of <code>java.util.*</code> classes (for example, <code>java.util.IdentityHashMap</code> would be 
    a {@link javolution.util.FastMap FastMap} with an {@link javolution.util.FastComparator#IDENTITY
    identity} key comparator).</P>

<P> Javolution collections are compliant with standard collections 
    (generic when built with the ant target <code>1.5</code>) and they can <b>safely</b> be used 
    with <a href="http://www.rtj.org/">RTSJ</a> virtual machines (e.g. if the capacity of 
    a collection increases, the extension part is allocated from the same memory 
    area as the collection itself).</P>

<P> They support direct iterations with the following advantages:
    <UL>
    <LI>Faster than iterators, see <A href="http://javolution.org/doc/benchmark.html">benchmark</A>.</LI>
    <LI>No object creation not even the iterator object itself. For example, visiting a tree structure using
        iterators creates as many iterators as they are nodes in the tree:[code]
        public static void visit(Collection<Collection> node) {
            for (Collection<Collection> i : node) { // Creates iterator.
                visit(i);
            }
        }[/code]
        Not so with direct iterations:[code]
        public static void visit(FastCollection<FastCollection> node) {
            for (FastCollection.Record r = node.head(), end = node.tail(); (r = r.getNext()) != end;) {
                visit(node.valueOf(r));
            }
        }[/code]</LI>
    <LI>Used to implement most of {@link javolution.util.FastCollection FastCollection} base class methods 
        (including {@link javolution.util.FastCollection#iterator iterator()}).</LI>
    <LI>Support forward/backward iterations from the start (head) or from the end (tail)</LI>
    <LI>Thread-Safe as long as the record sequence iterated over is not modified by another thread.
        Objects can safely be append/prepend by other threads during iteration but not inserted/removed
        <i>(Note: {@link javolution.util.FastMap#setShared Shared FastMap} ensures that map entries are not removed
                   and therefore are thread-safe without synchronization)</i>.</LI>
    <LI>Fully integrated with the JDK1.5+ generic framework (strong typing) and still compatible 
        with other platforms (J2ME, 1.4, GCJ).</LI>
    </UL>
    Here are few examples of direct iterations:[code]
        FastList<String> list;
        for (FastList.Node<String> n = list.head(), end = list.tail(); (n = n.getNext()) != end;) {
             String value = n.getValue(); // No typecast necessary.    
        }
        ...
        FastMap<String, Thread> map;
        for (FastMap.Entry<String, Thread> e = map.head(), end = map.tail(); (e = e.getNext()) != end;) {
             String key = e.getKey(); // No typecast necessary.
             Thread value = e.getValue(); // No typecast necessary.
        }[/code]</P>

<P> Users may provide a read-only view of any {@link javolution.util.FastCollection FastCollection} 
    (or {@link javolution.util.FastMap FastMap}) instance using the 
    {@link javolution.util.FastCollection#unmodifiable() FastCollection.unmodifiable()}
    (or {@link javolution.util.FastMap#unmodifiable FastMap.unmodifiable()}) method.
     For example:[code]
       public class Polynomial {
       
          private final FastSet<Term> _terms = new FastSet<Term>();

          // Read-only view (also thread-safe as terms are not "deleted").
          public Set<Term> getTerms() { 
              return _terms.unmodifiable();
          }
      }[/code]</P>

<P>  Although all collections capacity increases smoothly (no resizing/copy or rehashing ever performed),
     it is nevertheless possible to specify an initial capacity; in which case, <b>no dynamic 
     memory allocation is ever performed</b> as long as the collection size does not exceeds the specified 
     capacity! Finally, collections/maps can <b>safely</b> reside in <code>ImmortalMemory</code> 
     (<a href="http://www.rtj.org/">RTSJ</a>) and be accessible by all threads (including <code>NoHeapRealtimeThread</code>)</P>
     Here is a summary of the collection classes with their defining characteristics:
       <TABLE border="1" summary="Fast Collections Classes">
            <CAPTION><EM><B>Javolution Collections Classes</B></EM></CAPTION>
            <TR>
              <TD></TD>
              <TD><B>Ordering</B></TD>
              <TD><B>Duplication Allowed</B></TD>
              <TD><B>Custom Comparators</B></TD>
              <TD><B>Record Type</B></TD>
              <TD><B>Miscellaneous</B></TD>
            </TR>
            <TR>
              <TD>{@link javolution.util.FastTable FastTable}</TD>
              <TD>Insertion Order</TD>
              <TD>Yes</TD>
              <TD>{@link javolution.util.FastCollection#setValueComparator setValueComparator(FastComparator)}</TD>
              <TD>{@link javolution.util.FastTable.Index Index}</TD>
              <TD>Thread-safe random access collection<BR>
                  No array resize/copy ever performed</TD>
            </TR>
            <TR>
              <TD>{@link javolution.util.FastList FastList}</TD>
              <TD>Insertion Order</TD>
              <TD>Yes</TD>
              <TD>{@link javolution.util.FastCollection#setValueComparator setValueComparator(FastComparator)}</TD>
              <TD>{@link javolution.util.FastList.Node Node}</TD>
              <TD> Recycle their own nodes (no adverse effect on GC)</TD>
            </TR>
            <TR>
              <TD>{@link javolution.util.FastSet FastSet}</TD>
              <TD>Insertion Order</TD>
              <TD>No</TD>
              <TD>{@link javolution.util.FastList#setValueComparator setValueComparator(FastComparator)}</TD>
              <TD>{@link javolution.util.FastCollection.Record Record}</TD>
              <TD>Based on {@link javolution.util.FastSet FastMap} (same characteristics)</TD>
            </TR>
            <TR>
              <TD><CODE>FastTree</CODE></TD>
              <TD>Comparator</TD>
              <TD>No</TD>
              <TD><CODE>setValueComparator(FastComparator)</CODE></TD>
              <TD><CODE>TreeNode</CODE></TD>
              <TD><I>(not implemented)</I></TD>
            </TR>
            <TR>
              <TD>{@link javolution.util.FastMap FastMap}</TD>
              <TD>Insertion Order</TD>
              <TD>Key: No<BR>Value: Yes</TD>
              <TD>{@link javolution.util.FastMap#setKeyComparator setKeyComparator(FastComparator)}<BR>
                  {@link javolution.util.FastMap#setValueComparator setValueComparator(FastComparator)}</TD>
              <TD>{@link javolution.util.FastMap.Entry Entry}</TD>
              <TD>Thread-safe when marked as {@link javolution.util.FastMap#setShared shared}<BR>
                  No rehash/resize ever performed <BR>
                  Unshared maps recycle their own entries (no adverse effect on GC)</TD>
            </TR>
         </TABLE>
    </P>    
</BODY>