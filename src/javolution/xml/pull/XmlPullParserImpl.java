/*
 * Javolution - Java(TM) Solution for Real-Time and Embedded Systems
 * Copyright (C) 2005 - Javolution (http://javolution.org/)
 * All rights reserved.
 * 
 * Permission to use, copy, modify, and distribute this software is
 * freely granted, provided that this notice is preserved.
 */
package javolution.xml.pull;

import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.UnsupportedEncodingException;

import j2me.lang.CharSequence;
import j2me.lang.IllegalStateException;
import j2me.nio.ByteBuffer;

import javolution.io.Utf8ByteBufferReader;
import javolution.io.Utf8StreamReader;
import javolution.lang.PersistentReference;
import javolution.lang.Reusable;
import javolution.lang.Text;
import javolution.lang.TypeFormat;
import javolution.realtime.ObjectFactory;
import javolution.util.FastComparator;
import javolution.util.FastTable;
import javolution.xml.sax.Attributes;
import javolution.xml.sax.AttributesImpl;

/**
 * <p> This class provides a real-time XPP-like XML parser; this parser is
 *     <i>extremely</i> fast and <b>does not create temporary objects</b>
 *     (no garbage generated and no GC interruption).</p>
 *     
 * <p> The parser input source can be either a {@link #setInput(Reader) Reader},
 *     an {@link #setInput(InputStream) InputStream} or even a {@link 
 *     #setInput(ByteBuffer) ByteBuffer} (e.g. <code>MappedByteBuffer</code>).</p>
 *     
 * <p> This parser is light (less than 15Kbytes compressed) and maintains
 *     a very small memory footprint while parsing (e.g. less than 10Kbytes
 *     while parsing 32Mbytes files). Typical applications include SOAP
 *     messaging, embedded/realtime systems, web servers (possibly thousands
 *     instances running concurrently), etc.</p>
 *     
 * <p> Namespaces (SAX2 feature), comments, predefined entities
 *     (<code>&amp;amp;, &amp;lt;, &amp;gt;, &amp;apos;, &amp;quot;</code>)
 *     numeric character references (e.g. <code>&amp;#10;</code> for
 *     linefeed) and <code>CDATA</code> are recognized. Processing instructions,
 *     comments and entities declarations are ignored.</p>
 *     
 * <p> The {@link CharSequence CharSequence} generated by this parser have
 *     the following characteristics:
 *     <ul>
 *         <li> They are immutable within their definition scope. The <code>
 *              CharSequence</code> created while parsing an XML element are
 *              reused only after the element is out-of-scope (idem for the 
 *              {@link #getSaxAttributes attributes lists}).</li>
 *         <li> They support equality or lexical comparison with any
 *              <code>CharSequence</code> (e.g. <code>String</code>).</li>
 *         <li> They have the same hashcode than <code>String</code> and can be
 *              used to retrieve data from a <code>Map</code> (e.g.
 *              {@link javolution.util.FastMap FastMap}) for which 
 *              the keys are <code>String</code> instances.</li>
 *         <li> Like any <code>CharSequence</code>, they can be parsed
 *              to primitive types (e.g. int, double) using the utility class
 *              {@link TypeFormat}.</li>
 *     </ul></p>
 *     
 * <p> Finally, this parser does not break up character data during call back
 *     (the whole character data between markups is always being returned).</p>
 *
 * @author  <a href="mailto:javolution@arakelian.com">Gregory Arakelian</a>
 * @author  <a href="mailto:jean-marie@dautelle.com">Jean-Marie Dautelle</a>
 * @version 3.3, May 10, 2005
 */
public final class XmlPullParserImpl implements XmlPullParser, Reusable {

    /**
     * Holds a factory producing AttributesImpl instances.
     */
    private static final ObjectFactory ATTRIBUTES_IMPL_FACTORY = new ObjectFactory() {
        protected Object create() {
            return new AttributesImpl();
        }
    };

    /**
     * Holds the reader buffer capacity.
     */
    private static final int READER_BUFFER_CAPACITY = 2048;

    /**
     * Holds the configurable nominal length for the data array length (must be 
     * larger than the reader buffer capacity to avoid overflow).
     */
    private static final PersistentReference DATA_SIZE = new PersistentReference(
            "javolution.xml.pull.XmlPullParserImpl#DATA_SIZE", new Integer(
                    READER_BUFFER_CAPACITY * 2));

    /**
     * Holds the configurable nominal length for the CharSequenceImpl stack.
     */
    private static final PersistentReference SEQ_SIZE = new PersistentReference(
            "javolution.xml.pull.XmlPullParserImpl#SEQ_SIZE", new Integer(256));

    /**
     * Holds the parsing line.
     */
    private int _lineNumber;

    /**
     * Holds the column offset (column = _columnOffset + _index).
     */
    private int _columnOffset;

    /**
     * Holds the line length when line break occurs.
     */
    private int _lineLength;

    /**
     * Holds the current index in the character buffer.
     */
    private int _index;

    /**
     * Holds the data buffer for CharSequence produced by this parser.
     */
    private char[] _data = (char[]) new char[((Integer) DATA_SIZE.get())
            .intValue()];

    /**
     * Holds the current length of the data buffer (_data).
     */
    private int _length;

    /**
     * Holds the current depth.
     */
    private int _depth;

    /**
     * Holds the namespace  stack.
     */
    private final Namespaces _namespaces = new Namespaces();

    /**
     * Holds the current attributes (view over _attrStack.get(_depth)).
     */
    private AttributesImpl _attributes;

    /**
     * Holds a pool of AttributesImpl to avoid overwritting the current one.
     */
    private final FastTable _attrPool = new FastTable();

    /**
     * Holds working stack.
     */
    private final FastTable _elemStack = new FastTable();

    /**
     * Holds the character buffer used for reading.
     */
    private final char[] _chars = new char[READER_BUFFER_CAPACITY];

    /**
     * Holds the default stream reader (UTF-8).
     */
    private final Utf8StreamReader _inputStreamReader = new Utf8StreamReader(
            READER_BUFFER_CAPACITY);

    /**
     * Holds the default ByteBuffer reader (UTF-8).
     */
    private final Utf8ByteBufferReader _byteBufferReader = new Utf8ByteBufferReader();

    /**
     * Number of characters read from reader
     */
    private int _charsRead;

    /**
     * Holds local name (i.e. does not include prefix, if any).
     */
    private CharSequenceImpl _elemLocalName;

    /**
     * Holds element namespace (lookup performed using prefix and namespace stack).
     */
    private CharSequenceImpl _elemNamespace;

    /**
     * Holds qualified name (include prefix).
     */
    private CharSequenceImpl _elemQName;

    /**
     * Holds prefix.
     */
    private CharSequenceImpl _elemPrefix;

    /**
     * Holds attribute qualified name.
     */
    private CharSequenceImpl _attrQName;

    /**
     * Holds attribute prefix.
     */
    private CharSequenceImpl _attrPrefix;

    /**
     * Holds attribute value.
     */
    private CharSequenceImpl _attrValue;

    /**
     * Holds character sequence when parsing numeric literal.
     */
    private final CharSequenceImpl _num = new CharSequenceImpl();

    /**
     * Holds current event type
     */
    private int _eventType = END_DOCUMENT;

    /**
     * Input encoding, if known
     */
    private String _inputEncoding;

    /**
     * Indicates if event type is START_TAG, and tag is empty, i.e. <sometag/>
     */
    private boolean _isEmpty;

    /**
     * Holds index of the last non-whitespace character (-1 = all whitespace).
     */
    private int _nonwhitespace;

    /**
     * Holds reader used to get data
     */
    private Reader _reader;

    /**
     * Holds start of escape sequence
     */
    private int _escStart;

    /**
     * Holds saved parser state when escape sequence encountered.
     */
    private int _savedState;

    /**
     * Holds the start of text withing _data array.
     */
    private int _start;

    /**
     * Holds the parser state.
     */
    private int _state = CHAR_DATA;

    /**
     * Holds the text associated with current event.
     */
    private CharSequenceImpl _text;

    /**
     * Indicates if text contains non whitespace characters (characters 
     * others than space, cr, lf, tab).
     */
    private boolean _hasNonWhitespace;

    /**
     * Holds character sequences instances.
     */
    private CharSequenceImpl[] _seqs = new CharSequenceImpl[((Integer) SEQ_SIZE
            .get()).intValue()];

    /**
     * Holds character sequence index. 
     */
    private int _seqsIndex;

    /**
     * Holds number of character sequence instances allocated. 
     */
    private int _seqsCapacity;

    /**
     * Default constructor.
     */
    public XmlPullParserImpl() {
        _attributes = new AttributesImpl();
        _attrPool.add(_attributes);
    }

    /**
     * Sets the byte buffer this parser is going to process
     * (UTF-8 encoding).
     *
     * @param  byteBuffer the byte buffer with UTF-8 encoding.
     * @see    Utf8ByteBufferReader
     */
    public void setInput(ByteBuffer byteBuffer) {
        if (_reader != null)
            throw new IllegalStateException("Parser not reset.");
        _byteBufferReader.setByteBuffer(byteBuffer);
        _inputEncoding = "UTF-8";
        setInput(_byteBufferReader);
    }

    /**
     * Sets the input stream this parser is going to process
     * (UTF-8 encoding).
     *
     * @param in the input stream with UTF-8 encoding.
     * @see    Utf8StreamReader
     */
    public void setInput(InputStream in) {
        if (_reader != null)
            throw new IllegalStateException("Parser not reset.");
        _inputStreamReader.setInputStream(in);
        _inputEncoding = "UTF-8";
        setInput(_inputStreamReader);
    }

    // Implements XmlPullParser interface.
    public void setInput(InputStream inputStream, String inputEncoding)
            throws XmlPullParserException {
        if ((inputEncoding == null) || inputEncoding.equals("utf-8")
                || inputEncoding.equals("UTF-8")) {
            setInput(inputStream);
            return;
        }
        try {
            _inputEncoding = inputEncoding;
            setInput(new InputStreamReader(inputStream, inputEncoding));
        } catch (UnsupportedEncodingException e) {
            throw new XmlPullParserException(e.getMessage());
        }
    }

    // Implements XmlPullParser interface.
    public void setInput(Reader in) {
        if (_reader != null)
            throw new IllegalStateException("Parser not reset.");
        _reader = in;
		_eventType = START_DOCUMENT;
    }

    // Implements XmlPullParser interface.
    public void defineEntityReplacementText(CharSequence entityName,
            CharSequence replacementText) throws XmlPullParserException {
    }

    /**
     * Returns SAX-2 like attributes for the current element.
     * 
     * @return the attributes of the current element.
     */
    public Attributes getSaxAttributes() {
        return _attributes;
    }

    // Implements XmlPullParser interface.
    public int getAttributeCount() {
        if (_eventType != START_TAG)
            return -1;
        return _attributes.getLength();
    }

    // Implements XmlPullParser interface.
    public CharSequence getAttributeName(int index) {
        return _attributes.getLocalName(index);
    }

    // Implements XmlPullParser interface.
    public CharSequence getAttributeNamespace(int index) {
        return _attributes.getURI(index);
    }

    // Implements XmlPullParser interface.
    public CharSequence getAttributePrefix(int index) {
        return _attributes.getPrefix(index);
    }

    // Implements XmlPullParser interface.
    public String getAttributeType(int index) {
        return _attributes.getType(index);
    }

    // Implements XmlPullParser interface.
    public CharSequence getAttributeValue(CharSequence namespace,
            CharSequence name) {
        return _attributes.getValue(namespace, name);
    }

    // Implements XmlPullParser interface.
    public CharSequence getAttributeValue(int index) {
        return _attributes.getValue(index);
    }

    // Implements XmlPullParser interface.
    public int getDepth() {
        return _depth;
    }

    // Implements XmlPullParser interface.
    public int getEventType() throws XmlPullParserException {
        return _eventType;
    }

    // Implements XmlPullParser interface.
    public boolean getFeature(CharSequence name) {
        return false;
    }

    // Implements XmlPullParser interface.
    public String getInputEncoding() {
        return _inputEncoding;
    }

    // Implements XmlPullParser interface.
    public int getLineNumber() {
        int column = _columnOffset + _index;
        return (column != 0) ? _lineNumber : _lineNumber - 1;
    }

    // Implements XmlPullParser interface.
    public int getColumnNumber() {
        int column = _columnOffset + _index;
        return (column != 0) ? column : _lineLength;
    }

    // Implements XmlPullParser interface.
    public CharSequence getName() {
        return _elemLocalName;
    }

    // Implements XmlPullParser interface.
    public CharSequence getNamespace() {
        return _elemNamespace;
    }

    // Implements XmlPullParser interface.
    public CharSequence getPrefix() {
        return _elemPrefix;
    }

    /**
     * Returns the current element qualified name.
     *
     * @return the qualified name of the current element (prefix:localName).
     */
    public CharSequence getQName() {
        return _elemQName;
    }

    // Implements XmlPullParser interface.
    public CharSequence getNamespace(CharSequence prefix) {
        return _namespaces.getNamespaceUri(prefix);
    }

    // Implements XmlPullParser interface.
    public int getNamespaceCount(int depth) {
        return _namespaces.getNamespaceCount(depth);
    }

    // Implements XmlPullParser interface.
    public CharSequence getNamespacePrefix(int pos) {
        return _namespaces.getNamespacePrefix(pos);
    }

    // Implements XmlPullParser interface.
    public CharSequence getNamespaceUri(int pos) {
        return _namespaces.getNamespaceUri(pos);
    }

    // Implements XmlPullParser interface.
    public CharSequence getPositionDescription() {
        return Text.valueOf("line ").concat(Text.valueOf(getLineNumber()))
                .concat(Text.valueOf(", column ")).concat(
                        Text.valueOf(getColumnNumber()));
    }

    // Implements XmlPullParser interface.
    public Object getProperty(CharSequence name) {
        return null;
    }

    // Implements XmlPullParser interface.
    public CharSequence getText() {
        if (_eventType == START_DOCUMENT || _eventType == END_DOCUMENT) {
            return null;
        }
        return _text;
    }

    // Implements XmlPullParser interface.
    public char[] getTextCharacters(int[] holderForStartAndLength) {
        if (_eventType == START_DOCUMENT || _eventType == END_DOCUMENT) {
            holderForStartAndLength[0] = holderForStartAndLength[1] = -1;
            return null;
        }
        holderForStartAndLength[0] = _text.offset;
        holderForStartAndLength[1] = _text.length;
        return _text.data;
    }

    // Implements XmlPullParser interface.
    public int indexOf(CharSequence namespace, CharSequence name) {
        if (_eventType != START_TAG)
            throw new IndexOutOfBoundsException();
        return _attributes.getIndex(namespace, name);
    }

    // Implements XmlPullParser interface.
    public boolean isAttribute(CharSequence namespace, CharSequence name) {
        return indexOf(namespace, name) >= 0;
    }

    // Implements XmlPullParser interface.
    public boolean isAttributeDefault(int index) {
        return false;
    }

    // Implements XmlPullParser interface.
    public boolean isEmptyElementTag() throws XmlPullParserException {
        return _isEmpty;
    }

    // Implements XmlPullParser interface.
    public boolean isWhitespace() throws XmlPullParserException {
        if (_eventType == TEXT || _eventType == CDSECT)
            return !_hasNonWhitespace;
        throw new IllegalStateException();
    }

    // Implements XmlPullParser interface.
    public int next() throws XmlPullParserException, IOException {
        return (_eventType = parse(false));
    }

    // Implements XmlPullParser interface.
    public int nextTag() throws XmlPullParserException, IOException {
        int eventType = next();
        if (eventType == TEXT && isWhitespace()) { // skip whitespace
            eventType = next();
        }
        if (eventType != START_TAG && eventType != END_TAG) {
            throw error("expected start or end tag");
        }
        return eventType;
    }

    // Implements XmlPullParser interface.
    public CharSequence nextText() throws XmlPullParserException, IOException {
        if (getEventType() != START_TAG)
            throw error("parser must be on START_TAG to read next text");
        int eventType = next();
        if (eventType == TEXT) {
            CharSequence result = getText();
            eventType = next();
            if (eventType != END_TAG)
                throw error("event TEXT must be immediately followed by END_TAG");

            return result;
        } else if (eventType == END_TAG) {
            return CharSequenceImpl.EMPTY;
        } else {
            throw error("parser must be on START_TAG or TEXT to read text");
        }
    }

    // Implements XmlPullParser interface.
    public int nextToken() throws XmlPullParserException, IOException {
        return (_eventType = parse(true));
    }

    // Implements XmlPullParser interface.
    public void setFeature(String name, boolean state)
            throws XmlPullParserException {
    }

    // Implements XmlPullParser interface.
    public boolean getFeature(String name) {
        return false;
    }

    // Implements XmlPullParser interface.
    public void setProperty(String name, Object value)
            throws XmlPullParserException {
    }

    // Implements XmlPullParser interface.
    public Object getProperty(String name) {
        return null;
    }

    // Implements XmlPullParser interface.
    public void require(int type, CharSequence namespace, CharSequence name)
            throws XmlPullParserException, IOException {
        if (type != getEventType()
                || (namespace != null && !FastComparator.LEXICAL.areEqual(
                        namespace, getNamespace()))
                || (name != null && !FastComparator.LEXICAL.areEqual(name,
                        getName())))
            throw error("Require " + TYPES[type] + " failed");
    }

    /**
     * Parses the document.
     * 
     * @param tokenize indicates if tokenization is performed.
     * @return the event type.
     */
    private int parse(boolean tokenize) throws XmlPullParserException,
            IOException {
        switch (_eventType) { // Previous event.
        case START_DOCUMENT:
            _charsRead = _reader.read(_chars, 0, _chars.length);
            break;
        case END_DOCUMENT:
            throw error("End of document reached.");
        case START_TAG:
            if (_isEmpty) { // Previous empty tag, generates END_TAG automatically.
                _isEmpty = false;
                return END_TAG;
            }
            _elemPrefix = null;
            _elemLocalName = null;
            _elemNamespace = null;
            _elemQName = null;
            // Retrieves a new AttributesImpl instance from the stack
            // to avoid overriding the current one.
            if (_depth >= _attrPool.size()) {
                _attrPool.add(ATTRIBUTES_IMPL_FACTORY.newObject());
            }
            _attributes = (AttributesImpl) _attrPool.get(_depth);
            _attributes.reset();
            break;
        case END_TAG:
            _attributes.reset();
            _depth--;
            _length = _elemQName.offset;
            _start = _length;
            while (_seqs[--_seqsIndex] != _elemQName) {
            }
            _elemPrefix = null;
            _elemLocalName = null;
            _elemNamespace = null;
            _elemQName = null;
            break;
        default:
            _text = null;
            _hasNonWhitespace = false;
        }

        while (_index < _charsRead) {

            // Preprocessing.
            //
            char c = _chars[_index];
            if (++_index == _charsRead) { // Reloads buffer.
                _columnOffset += _index;
                _index = 0;
                _charsRead = _reader.read(_chars, 0, _chars.length);
                while ((_length + _charsRead) >= _data.length) {
                    // Potential overflow, resizes.
                    char[] tmp = new char[_data.length * 2];
                    System.arraycopy(_data, 0, tmp, 0, _data.length);
                    _data = tmp;
                    DATA_SIZE.set(new Integer(_data.length));
                }
            }
            // Replaces #xD and #xD#xA with #xA as per XML 1.0
            // recommendations (&2.11).
            if (c < 0x20) {
                if (c == 0xD) { // Replaces #xD with #xA
                    if ((_index < _charsRead) && (_chars[_index] == 0xA)) {
                        // Unless next char is #xA, then continue,
                        // #xD#xA will be replaced by #xA
                        continue;
                    }
                    c = 0xA;
                }
                if (c == 0xA) {
                    _lineNumber++; // Do it now, locator will readjust.
                    _lineLength = _columnOffset + _index;
                    _columnOffset = -_index; // column = 0
                } else if (c != 0x9) { // Not a tab.
                    throw error("Illegal XML character U+"
                            + Integer.toHexString(c));
                }
            }
            // Appends to buffer.
            _data[_length++] = c;
            // Detects escape sequence (e.g. character reference).
            if ((c == '&') && (_state != STATE_COMMENT) && (_state != PI)
                    && (_state != CDATA) && (_state != ESCAPE)) { // (&2.4)
                _savedState = _state;
                _escStart = _length;
                _state = ESCAPE;
            }

            // Main processing.
            //
            switch (_state) {
            case CHAR_DATA:
                if (c == '<') {
                    _state = MARKUP;
                    if (_hasNonWhitespace) {
                        int nbrChar = _length - _start - 1;
                        setText(_start, nbrChar);
                        _length = _start; // Do not keep character data.
                        return TEXT;
                    }
                    _length = _start; // Do not keep character data.
                } else if (!_hasNonWhitespace && c > ' ') {
                    _hasNonWhitespace = true;
                }
                break;

            case MARKUP:
                if (_length - _start == 1) {
                    if (c == '/') {
                        _state = CLOSE_TAG + READ_ELEM_NAME;
                        _length = _start;
                        _elemQName = newSeq();
                        _elemQName.offset = _start;
                    } else if (c == '?') {
                        _state = PI;
                        _length = _start;
                    } else if (c != '!') {
                        _state = OPEN_TAG + READ_ELEM_NAME;
                        _elemQName = newSeq();
                        _elemQName.offset = _start;
                    }
                } else if ((_length - _start == 3) && (_data[_start] == '!')
                        && (_data[_start + 1] == '-')
                        && (_data[_start + 2] == '-')) {
                    _state = STATE_COMMENT;
                    _length = _start;
                } else if ((_length - _start == 8) && (_data[_start] == '!')
                        && (_data[_start + 1] == '[')
                        && (_data[_start + 2] == 'C')
                        && (_data[_start + 3] == 'D')
                        && (_data[_start + 4] == 'A')
                        && (_data[_start + 5] == 'T')
                        && (_data[_start + 6] == 'A')
                        && (_data[_start + 7] == '[')) {
                    _state = CDATA;
                    _nonwhitespace = -1;
                    _length = _start;
                } else if (c == '>') {
                    _state = CHAR_DATA;
                    _length = _start;
                }
                break;

            case STATE_COMMENT:
                if ((c == '>') && (_length - _start >= 3)
                        && (_data[_length - 2] == '-')
                        && (_data[_length - 3] == '-')) {
                    _state = CHAR_DATA;
                    int nbrChar = _length - _start - 3;
                    _length = _start; // Do not keep comment.
                    if (tokenize && nbrChar > 0) {
                        setText(_start, nbrChar);
                        return COMMENT;
                    }
                }
                break;

            case PI: // Ignores Processing Instructions.
                if ((c == '>') && (_length - _start >= 2)
                        && (_data[_length - 2] == '?')) {
                    _state = CHAR_DATA;
                    int nbrChar = _length - _start - 2;
                    _length = _start; // Do not keep Processing Instructions.
                    if (tokenize && nbrChar > 0) {
                        setText(_start, nbrChar);
                        return PROCESSING_INSTRUCTION;
                    }
                }
                break;

            case CDATA:
                if ((c == '>') && (_length - _start >= 3)
                        && (_data[_length - 2] == ']')
                        && (_data[_length - 3] == ']')) {
                    _state = CHAR_DATA;
                    int nbrChar = _length - _start - 3;
                    _hasNonWhitespace = !(_nonwhitespace == _start + nbrChar
                            + 1);
                    setText(_start, nbrChar);
                    _length = _start; // Do not keep CDATA
                    return CDSECT;
                }
                if ((_nonwhitespace == -1) && (c > ' '))
                    _nonwhitespace = _length;
                break;

            // OPEN_TAG:
            case OPEN_TAG + READ_ELEM_NAME:
                if (c == '>') {
                    _elemQName.length = _length - _elemQName.offset - 1;
                    _elemQName.data = _data;
                    _state = CHAR_DATA;
                    _start = _length;
                    return processElement(OPEN_TAG);
                } else if (c == '/') {
                    _elemQName.length = _length - _elemQName.offset - 1;
                    _elemQName.data = _data;
                    _state = OPEN_TAG + EMPTY_TAG;
                } else if ((c == ':') && (_elemPrefix == null)) {
                    _elemPrefix = newSeq();
                    _elemPrefix.offset = _elemQName.offset;
                    _elemPrefix.length = _length - _elemQName.offset - 1;
                    _elemPrefix.data = _data;
                } else if (c <= ' ') {
                    _elemQName.length = _length - _elemQName.offset - 1;
                    _elemQName.data = _data;
                    _state = OPEN_TAG + ELEM_NAME_READ;
                }
                break;
            case OPEN_TAG + ELEM_NAME_READ:
                if (c == '>') {
                    _state = CHAR_DATA;
                    _start = _length;
                    return processElement(OPEN_TAG);
                } else if (c == '/') {
                    _state = OPEN_TAG + EMPTY_TAG;
                } else if (c > ' ') {
                    _attrQName = newSeq();
                    _attrQName.offset = _length - 1;
                    _state = OPEN_TAG + READ_ATTR_NAME;
                }
                break;
            case OPEN_TAG + READ_ATTR_NAME:
                if (c <= ' ') {
                    _attrQName.length = _length - _attrQName.offset - 1;
                    _attrQName.data = _data;
                    _state = OPEN_TAG + ATTR_NAME_READ;
                } else if (c == '=') {
                    _attrQName.length = _length - _attrQName.offset - 1;
                    _attrQName.data = _data;
                    _state = OPEN_TAG + EQUAL_READ;
                } else if ((c == ':') && (_attrPrefix == null)) {
                    _attrPrefix = newSeq();
                    _attrPrefix.offset = _attrQName.offset;
                    _attrPrefix.length = _length - _attrQName.offset - 1;
                    _attrPrefix.data = _data;
                }
                break;
            case OPEN_TAG + ATTR_NAME_READ:
                if (c == '=') {
                    _state = OPEN_TAG + EQUAL_READ;
                } else if (c > ' ') {
                    throw error("'=' expected");
                }
                break;
            case OPEN_TAG + EQUAL_READ:
                if (c == '\'') {
                    _attrValue = newSeq();
                    _attrValue.offset = _length;
                    _state = OPEN_TAG + READ_ATTR_VALUE_SIMPLE_QUOTE;
                } else if (c == '\"') {
                    _attrValue = newSeq();
                    _attrValue.offset = _length;
                    _state = OPEN_TAG + READ_ATTR_VALUE_DOUBLE_QUOTE;
                } else if (c > ' ') {
                    throw error("Quotes expected");
                }
                break;
            case OPEN_TAG + READ_ATTR_VALUE_SIMPLE_QUOTE:
                if (c == '\'') {
                    _attrValue.length = _length - _attrValue.offset - 1;
                    _attrValue.data = _data;
                    processAttribute();
                    _state = OPEN_TAG + ELEM_NAME_READ;
                }
                break;
            case OPEN_TAG + READ_ATTR_VALUE_DOUBLE_QUOTE:
                if (c == '\"') {
                    _attrValue.length = _length - _attrValue.offset - 1;
                    _attrValue.data = _data;
                    processAttribute();
                    _state = OPEN_TAG + ELEM_NAME_READ;
                }
                break;
            case OPEN_TAG + EMPTY_TAG:
                if (c == '>') {
                    _state = CHAR_DATA;
                    _start = _length;
                    return processElement(OPEN_TAG + EMPTY_TAG);
                } else {
                    throw error("'>' expected");
                }

            // CLOSE_TAG:
            case CLOSE_TAG + READ_ELEM_NAME:
                if (c == '>') {
                    _elemQName.length = _length - _elemQName.offset - 1;
                    _elemQName.data = _data;
                    _state = CHAR_DATA;
                    _start = _length;
                    return processElement(CLOSE_TAG);
                } else if ((c == ':') && (_elemPrefix == null)) {
                    _elemPrefix = newSeq();
                    _elemPrefix.offset = _elemQName.offset;
                    _elemPrefix.length = _length - _elemQName.offset - 1;
                    _elemPrefix.data = _data;
                } else if (c <= ' ') {
                    _elemQName.length = _length - _elemQName.offset - 1;
                    _elemQName.data = _data;
                    _state = CLOSE_TAG + ELEM_NAME_READ;
                }
                break;
            case CLOSE_TAG + ELEM_NAME_READ:
                if (c == '>') {
                    _state = CHAR_DATA;
                    _start = _length;
                    return processElement(CLOSE_TAG);
                } else if (c > ' ') {
                    throw error("'>' expected");
                }
                break;

            case ESCAPE:
                if (c == ';') { // Escape terminator.
                    if ((_length - _escStart == 3)
                            && (_data[_length - 3] == 'l')
                            && (_data[_length - 2] == 't')) {
                        _data[_escStart - 1] = '<';
                    } else if ((_length - _escStart == 3)
                            && (_data[_length - 3] == 'g')
                            && (_data[_length - 2] == 't')) {
                        _data[_escStart - 1] = '>';
                    } else if ((_length - _escStart == 5)
                            && (_data[_length - 5] == 'a')
                            && (_data[_length - 4] == 'p')
                            && (_data[_length - 3] == 'o')
                            && (_data[_length - 2] == 's')) {
                        _data[_escStart - 1] = '\'';
                    } else if ((_length - _escStart == 5)
                            && (_data[_length - 5] == 'q')
                            && (_data[_length - 4] == 'u')
                            && (_data[_length - 3] == 'o')
                            && (_data[_length - 2] == 't')) {
                        _data[_escStart - 1] = '\"';
                    } else if ((_length - _escStart == 4)
                            && (_data[_length - 4] == 'a')
                            && (_data[_length - 3] == 'm')
                            && (_data[_length - 2] == 'p')) {
                        _data[_escStart - 1] = '&';
                    } else { // Character reference (&4.1)
                        if ((_length - _escStart > 1)
                                && (_data[_escStart] == '#')) {
                            try {
                                if (_data[_escStart + 1] == 'x') { // Hexadecimal.
                                    _num.offset = _escStart + 2;
                                    _num.length = _length - _escStart - 3;
                                    _num.data = _data;
                                    _data[_escStart - 1] = (char) TypeFormat
                                            .parseInt(_num, 16);
                                } else { // Decimal.
                                    _num.offset = _escStart + 1;
                                    _num.length = _length - _escStart - 2;
                                    _num.data = _data;
                                    _data[_escStart - 1] = (char) TypeFormat
                                            .parseInt(_num);
                                }
                            } catch (NumberFormatException e) {
                                throw error("Ill-formed character reference");
                            }
                        } else {
                            throw error("'#' expected");
                        }
                    }
                    _state = _savedState;
                    _length = _escStart;
                } else if (c <= ' ') {
                    throw error("';' expected");
                }
                break;

            default:
                throw error("State unknown: " + _state);
            }
        }

        if (_depth != 0)
            throw error("Unexpected end of file");
        reset();
        return END_DOCUMENT;
    }

    // Defines parsing states.
    private static final int CHAR_DATA = 0x10;

    private static final int MARKUP = 0x20;

    private static final int STATE_COMMENT = 0x30;

    private static final int PI = 0x40;

    private static final int CDATA = 0x50;

    private static final int OPEN_TAG = 0x60;

    private static final int CLOSE_TAG = 0x70;

    private static final int ESCAPE = 0x90;

    // Defines element parsing sub-states.
    private static final int READ_ELEM_NAME = 0x01;

    private static final int ELEM_NAME_READ = 0x02;

    private static final int READ_ATTR_NAME = 0x03;

    private static final int ATTR_NAME_READ = 0x04;

    private static final int EQUAL_READ = 0x05;

    private static final int READ_ATTR_VALUE_SIMPLE_QUOTE = 0x06;

    private static final int READ_ATTR_VALUE_DOUBLE_QUOTE = 0x07;

    private static final int EMPTY_TAG = 0x08;

    /**
     * Processes the attribute just read.
     *
     * @throws XmlPullParserException any SAX exception, possibly wrapping another
     *         exception.
     */
    private void processAttribute() throws XmlPullParserException {
        if (_attrPrefix == null) { // No prefix.
            if (isXmlns(_attrQName)) { // Sets default namespace.
                _namespaces.map(null, _attrValue);
            } else {
                _attributes
                        .addAttribute(CharSequenceImpl.EMPTY, _attrQName,
                                CharSequenceImpl.EMPTY, _attrQName, "CDATA",
                                _attrValue);
            }
        } else { // Prefix.
            CharSequenceImpl localName = newSeq();
            localName.offset = _attrQName.offset + _attrPrefix.length + 1;
            localName.length = _attrQName.length - _attrPrefix.length - 1;
            localName.data = _attrQName.data;

            if (isXmlns(_attrPrefix)) { // Namespace association.
                _namespaces.map(localName, _attrValue);
            } else { // Searches URI
                CharSequenceImpl uri = _namespaces.getNamespaceUri(_attrPrefix);
                if (uri != null) {
                    _attributes.addAttribute(uri, localName, _attrPrefix,
                            _attrQName, "CDATA", _attrValue);
                } else {
                    error("Namespace " + _attrPrefix + " undefined");
                }
            }
            _attrPrefix = null; // Resets.
        }
    }

    /**
     * Processes the element just read.
     *
     * @param  state the current parser state.
     * @throws XmlPullParserException any SAX exception, possibly wrapping another
     *         exception.
     */
    private int processElement(int state) throws XmlPullParserException {
        if (_elemPrefix != null) { // Prefix, sets uri.
            _elemLocalName = newSeq();
            _elemLocalName.offset = _elemQName.offset + _elemPrefix.length + 1;
            _elemLocalName.length = _elemQName.length - _elemPrefix.length - 1;
            _elemLocalName.data = _elemQName.data;
            _elemNamespace = _namespaces.getNamespaceUri(_elemPrefix);
            if (_elemNamespace == null)
                throw error("Namespace " + _elemPrefix + " undefined");
        } else { // No prefix.
            _elemLocalName = _elemQName;
            _elemNamespace = _namespaces.getNamespaceUri(null); // Default namespace.
        }
        if (state == OPEN_TAG + EMPTY_TAG) {
            _isEmpty = true;
            _depth++;
            _namespaces.flush();
            return START_TAG;

        } else if (state == OPEN_TAG) {
            _depth++;
            _elemStack.addLast(_elemQName);
            _elemStack.addLast(_elemNamespace);
            _elemStack.addLast(_elemLocalName);
            _elemStack.addLast(_elemPrefix);
            _namespaces.push();
            return START_TAG;

        } else if (state == CLOSE_TAG) {
            _elemPrefix = (CharSequenceImpl) _elemStack.removeLast();
            _elemLocalName = (CharSequenceImpl) _elemStack.removeLast();
            _elemNamespace = (CharSequenceImpl) _elemStack.removeLast();
            CharSequenceImpl qName = _elemQName; // Current.
            _elemQName = (CharSequenceImpl) _elemStack.removeLast();
            if (!_elemQName.equals(qName))
                throw error("Unexpected end tag for " + _elemQName);
            _namespaces.pop();
            return END_TAG;

        } else {
            throw error("Unexpected state: " + state);
        }
    }

    // Implements Reusable.
    public void reset() {
        try {
            if (_reader != null)
                _reader.close();
        } catch (IOException e) {
            // Ignores exceptions.
        }

        // Resets all members (alphabetically ordered).
        _attributes = (AttributesImpl) _attrPool.get(0);
        for (int i = 0, n = _attrPool.size(); i < n;) {
            ((AttributesImpl) _attrPool.get(i++)).reset();
        }
        _attrPrefix = null;
        _attrQName = null;
        _attrValue = null;
        _attrQName = null;
        _charsRead = 0;
        _columnOffset = 0;
        _depth = 0;
        _elemLocalName = null;
        _elemNamespace = null;
        _elemPrefix = null;
        _elemQName = null;
        _elemStack.reset();
        _escStart = 0;
        _eventType = END_DOCUMENT;
        _hasNonWhitespace = false;
        _index = 0;
        _inputEncoding = null;
        _isEmpty = false;
        _length = 0;
        _lineLength = 0;
        _lineNumber = 0;
        _namespaces.reset();
        _nonwhitespace = 0;
        _reader = null;
        _savedState = 0;
        _seqsIndex = 0;
        _start = 0;
        _state = CHAR_DATA;
        _text = null;
    }

    /**
     * Sets current text.
     *
     * @param  start the start index.
     * @param  end the end index.
     */
    private void setText(int start, int length) {
        _text = newSeq();
        _text.data = _data;
        _text.offset = start;
        _text.length = length;
    }

    /**
     * Indicates if the specified character sequence is xmlns.
     *
     * @param  chars the characters sequence to be tested.
     * @return <code>chars.equals("xmlns")</code>
     */
    private static boolean isXmlns(CharSequenceImpl chars) {
        return (chars.length == 5) && (chars.data[chars.offset] == 'x')
                && (chars.data[chars.offset + 1] == 'm')
                && (chars.data[chars.offset + 2] == 'l')
                && (chars.data[chars.offset + 3] == 'n')
                && (chars.data[chars.offset + 4] == 's');
    }

    private XmlPullParserException error(String message) {
        XmlPullParserException e = new XmlPullParserException(message, this,
                null);
        return e;
    }

    // Returns a new character sequence from the pool.
    private CharSequenceImpl newSeq() {
        return (_seqsIndex < _seqsCapacity) ? _seqs[_seqsIndex++] : newSeq2();
    }

    private CharSequenceImpl newSeq2() {
        if (_seqsCapacity++ >= _seqs.length) { // Resizes. 
            CharSequenceImpl[] tmp = new CharSequenceImpl[_seqs.length * 2];
            System.arraycopy(_seqs, 0, tmp, 0, _seqs.length);
            _seqs = tmp;
            SEQ_SIZE.set(new Integer(_seqs.length));
        }
        return _seqs[_seqsIndex++] = (CharSequenceImpl) CharSequenceImpl.FACTORY
                .newObject();
    }

}