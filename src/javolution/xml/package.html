<body>
<p>Provides support for the encoding of objects, and the objects reachable from them,
   into <code>XML</code>; and the complementary reconstruction of the
   object graph from <code>XML</code>. 
</p>

<p> This xml marshalling/unmarshalling facility has the following advatanges:<ul>
    <li> Very fast and small memory footprint (unmarshalling performed using
         our real-time {@link javolution.xml.pull.XmlPullParserImpl pull parser}).</li>
    <li> Performance on a par or better than default Java<sup>TM</sup> Serialization/Deserialization 
         (See <a href="https://bindmark.dev.java.net/">bindmark</a> for performance comparison).</li>
    <li> Runs on any platform including J2ME CLDC 1.0 It does not require reflection or 
         or any interface (e.g. <code>Serializable</code>) to be implemented.</li>
    <li> The XML mapping can be defined for a top class (or interface) and is automatically inherited by all sub-classes
         (or all implementing classes).</li>
    <li> Allows for sharing and unicity  (through the use of factory methods instead of constructors).</li>
    <li> The XML mapping is customizable and is not tight to the class internal representation
         (backward compatibility ensured even when implementation changes or after obfuscation).</li>
    <li> The XML mapping can be dynamically changed (even while parsing/formatting).</li>
    <li> Integrated with NIO high-performance framework (e.g. <code>java.nio.ByteBuffer</code>).</li>
    <li> Can be used when the application has absolutely no control over the XML format 
         (e.g. SOAP messages) or with xml data produced by other facilities.</li>
    </ul>
</p>

<p> The default XML mapping for a class and its sub-classes is typically defined using 
    a <code>static final</code> {@link javolution.xml.XmlFormat XmlFormat} instance. 
    For example:<pre>
      public abstract class Graphic {
          private boolean _isVisible;
          private Paint _paint; // null if none.
          private Stroke _stroke; // null if none.
          private Transform _transform; // null if none.
           
          // XML format with name associations (members identified by an unique name).
          // See {@link javolution.xml.XmlFormat XmlFormat} for examples of positional associations.
          public static final XmlFormat&lt;Graphic> XML = new XmlFormat&lt;Graphic>(Graphic.class) {
               public void format(Graphic g, XmlElement xml) {
                   xml.setAttribute("isVisible", g._isVisible); 
                   xml.add(g._paint, "Paint");
                   xml.add(g._stroke, "Stroke");
                   xml.add(g._transform, "Transform");
               }
               public Graphic parse(XmlElement xml) {
                   Graphic g = xml.object();
                   g._isVisible = xml.getAttribute("isVisible", true);
                   g._paint = xml.get("Paint");
                   g._stroke = xml.get("Stroke");
                   g._transform = xml.get("Transform");
                   return g;
              }
          };
      }</pre>
    Sub-classes may override the inherited XML format:<pre>
      public class Area extends Graphic {
          private Shape _geometry;  
        
          // Adds geometry to format.
          public static final XmlFormat&lt;Area> XML = new XmlFormat&lt;Area>(Area.class) {
              public void format(Area area, XmlElement xml) {
                  Graphic.XML.format(area, xml); 
                  xml.add(area._geometry,"Geometry");
              }
              public Area parse(XmlElement xml) {
                  Area area = (Area) Graphic.XML.parse(xml); 
                  area._geometry = xml.get("Geometry");
                  return area;
              }
          };
      }</pre>
    
    The following writes a graphic area to a file, then reads it:<pre>
      ObjectWriter&lt;Area> areaWriter = new ObjectWriter&lt;Area>();
      areaWriter.setPackagePrefix("g", "org.jscience.graphics.geom2d"); // Use namespace for package (optional).
      areaWriter.write(area, new FileOutputStream("C:/area.xml"));
      ...
      Area a = new ObjectReader&lt;Area>().read(new FileInputStream("C:/area.xml"));</pre> 
 
    <p><i>For multiple objects transmissions over open I/O streams, 
    {@link javolution.xml.XmlInputStream} and {@link javolution.xml.XmlOutputStream} are recommended.</i></p>

    Here is an example of valid XML representation for an area:<pre>
      &lt;g:Area xmlns:j="http://javolution.org" xmlns:g="java:org.jscience.graphics.geom2d" isVisible="true"&gt;
          &lt;Paint j:class="java.awt.Color" rgb="#F3EBC6"/&gt;
          &lt;Geometry j:class="org.jscience.graphics.geom2d.Polygon" id="1"&gt;
              &lt;Point x="123" y="-34"/&gt;
              &lt;Point x="-43" y="-34"/&gt;
              &lt;Point x="-12" y="123"/&gt;
          &lt;/Geometry&gt;
      &lt;/g:Area&gt;</pre>
   
</p>
<p> The following table illustrates the variety of xml representations supported 
    (Foo class with a single String member named text):
    <center>
      <table cellpadding="2" cellspacing="2" border="1" style="text-align: left"><tbody>
      <tr>
        <td style="vertical-align: top; text-align: center;"><span style="font-weight: bold;">XML FORMAT</span></td>
        <td style="vertical-align: top; text-align: center;"><span style="font-weight: bold;">XML DATA</span></td>
      </tr>
      <tr>
<td><pre>XmlFormat&lt;Foo&gt; XML = new XmlFormat&lt;Foo&gt;(Foo.class) {
    public void format(Foo foo, XmlElement xml) {
        xml.setAttribute("text", foo.text); 
    }
    public Foo parse(XmlElement xml) {
        Foo foo = xml.object();
        foo.text = xml.getAttribute("text", "");
        return foo;
    }
};</pre></td>
<td><pre>
 <b>&lt;!-- Member as attribute --&gt;</b>
 &lt;Foo text="This is a text"/&gt;
</pre></td>
      </tr>
      
      <tr>
<td><pre>XmlFormat&lt;Foo&gt; XML = new XmlFormat&lt;Foo&gt;(Foo.class) {
    public void format(Foo foo, XmlElement xml) {
        xml.add(foo.text); 
    }
    public Foo parse(XmlElement xml) {
        Foo foo = xml.object();
        foo.text = (String) xml.getNext();
        return foo;
    }
};</pre></td>
<td><pre>
 <b>&lt;!-- Member as anonymous nested element --&gt;</b>
 &lt;Foo&gt;
     &lt;java.lang.String value="This is a text"/&gt;
 &lt;/Foo&gt;
</pre></td>
      </tr>

      <tr>
<td><pre>XmlFormat&lt;Foo&gt; XML = new XmlFormat&lt;Foo&gt;(Foo.class) {
    public void format(Foo foo, XmlElement xml) {
        xml.add(CharacterData.valueOf(foo.text)); 
    }
    public Foo parse(XmlElement xml) {
        Foo foo = xml.object();
        foo.text = xml.getNext().toString();
        return foo;
    }
};</pre></td>
<td><pre>
 <b>&lt;!-- Member as Character Data --&gt;</b>
 &lt;Foo&gt;
     &lt;![CDATA[This is a text]]&gt;
 &lt;/Foo&gt;
</pre></td>
      </tr>

      <tr>
<td><pre>XmlFormat&lt;Foo&gt; XML = new XmlFormat&lt;Foo&gt;(Foo.class) {
    public void format(Foo foo, XmlElement xml) {
        xml.add(foo.text, "text"); 
    }
    public Foo parse(XmlElement xml) {
        Foo foo = xml.object();
        foo.text = xml.get("text");
        return foo;
    }
};</pre></td>
<td><pre>
 <b>&lt;!-- Member as named element of unknown type  --&gt;</b>
 &lt;Foo&gt;
     &lt;text j:class="java.lang.String" value="This is a text"/&gt;
 &lt;/Foo&gt;
</pre></td>
      </tr>

      <tr>
<td><pre>XmlFormat&lt;Foo&gt; XML = new XmlFormat&lt;Foo&gt;(Foo.class) {
    public void format(Foo foo, XmlElement xml) {
        xml.add(foo.text, "text", XmlFormat.STRING_XML); 
    }
    public Foo parse(XmlElement xml) {
        Foo foo = xml.object();
        foo.text = xml.get("text", XmlFormat.STRING_XML);
        return foo;
    }
};</pre></td>
<td><pre>
 <b>&lt;!-- Member as named element of known type --&gt;</b>
 &lt;Foo&gt;
     &lt;text value="This is a text"/&gt;
 &lt;/Foo&gt;
</pre></td>
      </tr>
      </tbody></table>
    </center>
    <p><i>Applications may also temporarily change the classes {@link javolution.xml.XmlFormat#setAlias aliases}
    and associated {@link javolution.xml.XmlFormat#setFormat formats} during parsing/formatting.</i></p>
</p>

<p> The {@link javolution.xml.XmlFormat XmlFormat} does not have to use the class
    public no-arg constructor ({@link javolution.xml.XmlElement#object xml.object()}), instances can be created using factory methods, 
    private constructors (with constructor parameters set from the XML element) or even retrieved from a collection (if the object is shared
    or unique). For example:<pre>
        public final class Point { // Immutable, no no-arg constructor.
            public static final XmlFormat&lt;Point> XML = new XmlFormat&lt;Point>(Point.class) {
                public void format(Point point, XmlElement xml) {
                    xml.setAttribute("x", point._x);
                    xml.setAttribute("y", point._y);
                }
                public Point parse(XmlElement xml) {
                    return Point.valueOf(xml.getAttribute("x", 0.0), xml.getAttribute("y", 0.0)); 
                }
            };
            private double _x;
            private double _y;
            private Point() {}; // No-arg constructor not visible.
            public static Point valueOf(double x, double y) { ... }
        }
        ...
        private class MyPrivateGraphic extends Graphic { // Private class (can be inner class).
            static final XmlFormat&lt;MyPrivateGraphic> XML = new XmlFormat&lt;MyPrivateGraphic>(MyPrivateGraphic.class) {
                public MyPrivateGraphic allocate(XmlElement xml) {
                    return new MyPrivateGraphic(); 
                }
                public void format(MyPrivateGraphic g, XmlElement xml) {
                    Graphic.XML.format(g, xml); // Calls parent format.
                }
                public MyPrivateGraphic parse(XmlElement xml) {
                    return (MyPrivateGraphic) Graphic.XML.parse(xml); // Calls parent parse. 
                }
            };
        }</pre>
</p>

<p> The following illustrates how xml cross-references are supported (including circular references):<pre>
    public static class Polygon {
        // For cross references local to a xml document, parsing/formatting should be 
        // performed within a {@link javolution.realtime.LocalContext LocalContext}.
        public static final XmlFormat&lt;Polygon&gt; XML = new XmlFormat&lt;Polygon&gt;(Polygon.class) {
            public void format(Polygon polygon, XmlElement xml) {
                Integer id = POLYGON_TO_ID.get(polygon);
                if (id != null) { // Reference.
                    xml.setAttribute("ref", id);
                    return;
                }
                id = POLYGON_TO_ID.size() + 1;
                POLYGON_TO_ID.put(polygon, id);
                xml.setAttribute("id", id);

                // Writes vertices.
                xml.setAttribute("length", polygon._vertices.length);
                for (Point p : polygon._vertices) {
                    xml.add(p, "Point", Point.XML);
                }
            }

            public Polygon parse(XmlElement xml) {
                Integer id = xml.getAttribute("ref", -1);
                if (id >= 0) // Reference
                    return ID_TO_POLYGON.get(id);
                Polygon polygon = new Polygon();
                ID_TO_POLYGON.put(xml.getAttribute("id", -1), polygon);

                // Reads vertices.
                polygon._vertices = new Point[xml.getAttribute("length", 0)];
                for (int i = 0; i < polygon._vertices.length; i++)
                    polygon._vertices[i] = xml.get("Point", Point.XML);
                return polygon;
            }
        };
        private static LocalMap&lt;Polygon, Integer&gt; POLYGON_TO_ID = new LocalMap&lt;Polygon, Integer&gt;()
                .setKeyComparator(FastComparator.IDENTITY);
        private static LocalMap&lt;Integer, Polygon&gt; ID_TO_POLYGON = new LocalMap&lt;Integer, Polygon&gt;();

        Point[] _vertices;
    }</pre>
    Here the XML representation of a list of three polygons, 
    the first and the last one being shared:<pre>
      &lt;java.util.ArrayList xmlns:j="http://javolution.org" xmlns:geom2d="java:org.jscience.graphics.geom2d">
          &lt;geom2d:Polygon id="1"&gt;
              &lt;Point x="123" y="-34"/&gt;
              &lt;Point x="-43" y="-34"/&gt;
              &lt;Point x="-12" y="123"/&gt;
          &lt;/geom2d:Polygon&gt;
          &lt;geom2d:Polygon id="2"&gt;
              &lt;Point x="-43" y="-34"/&gt;
              &lt;Point x="123" y="-34"/&gt;
              &lt;Point x="-12" y="123"/&gt;
          &lt;/geom2d:Polygon&gt;
          &lt;geom2d:Polygon ref="1"/&gt;
      &lt;/java.util.ArrayList&gt;</pre>
</p>

<p> Finally, here is a code excerpt illustrating how objects can be 
    efficiently transmitted over the network using the <code>java.nio</code> facility
    instead of classic I/O (slower):<pre>
      // Client thread.
      ObjectReader or = new ObjectReader();
      ByteBuffer bb = ByteBuffer.allocateDirect(XML_SIZE);
      SocketChannel sc = SocketChannel.open(new InetSocketAddress(LOCAL_HOST, PORT));
      sc.read(bb); // Reads socket into byte buffer.
      bb.flip();
      Object obj = or.read(bb); // Parses byte buffer.
      bb.clear();
          ...
      // Server thread.
      ObjectWriter ow = new ObjectWriter();
      ByteBuffer bb = ByteBuffer.allocateDirect(XML_SIZE);
      ServerSocketChannel ssc = ServerSocketChannel.open();
      ssc.socket().bind(new InetSocketAddress(PORT));
      SocketChannel sc = ssc.accept(); // Waits for connections.
      ow.write(obj, bb); // Formats object into byte buffer.
      bb.flip();
      sc.write(bb); // Sends byte buffer.
      bb.clear();</pre>
      
     <p><i>When using NIO, the <code>ByteBuffer</code> capacity has to be large enough to hold 
           the largest XML representation of the objects being transmitted.</i></p>
</p>
</body>